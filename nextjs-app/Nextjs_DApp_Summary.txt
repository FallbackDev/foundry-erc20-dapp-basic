# Next.js DApp 运行原理全链路总结 - 给 Solidity 开发者的指南

## 1. 宏观流程：从输入网址到页面显示 (Next.js SSR)

当用户在浏览器输入 `http://localhost:3000` 并回车时，幕后发生了一连串“接力跑”：

**第一棒：服务器 (Next.js 框架)**
1.  **路由匹配**: 收到 `/` 请求，Next.js 自动定位到 `src/app` 目录。
2.  **组件实例化**: 
    *   执行 `page.tsx` 里的 `Home()` 函数 -> 得到页面主体内容 (作为 `children`)。
3.  **布局组装**: 
    *   执行 `layout.tsx` 里的 `RootLayout({ children })`。
    *   在 `RootLayout` 内部，调用 `Providers`，把 `children` 塞进去。
    *   **最终结构**: `<Providers> <Home /> </Providers>`。
4.  **生成快照**: 将上述结构渲染成纯文本的 HTML 字符串（这时页面是死的，显示的余额可能是默认值或 Loading）。
5.  **发送**: 将 HTML 发回给浏览器。

**第二棒：浏览器 (Client)**
6.  **首屏显示**: 浏览器收到 HTML，立即画在屏幕上（用户瞬间看到界面，无白屏）。
7.  **下载脚本**: 浏览器紧接着下载打包好的 JavaScript 文件。
8.  **水合 (Hydration) - 关键一步**: 
    *   浏览器执行 JS，启动 React 引擎。
    *   React 扫描页面，把 `onClick` 等事件监听器“挂”在该有的按钮上。
    *   **此时，页面从“蜡像”变成了“真人”。**

## 2. DApp 核心逻辑：React + Wagmi 闭环

页面活了之后，就是我们写的那些 Hook 在工作：

1.  **连接 (useAccount)**: 检查浏览器插件 (MetaMask)，拿到 `address`。
2.  **查询 (useReadContract)**: 
    *   拿到 `address` 后，自动发 RPC 请求查 `balanceOf`。
    *   数据回来后，React 自动把 HTML 里的 "Loading/0" 替换成 "100"。
3.  **交互 (useWriteContract)**: 
    *   用户点按钮 -> 触发 `writeContract` -> 唤起钱包签名 -> 广播交易。
4.  **反馈 (useWaitForTransactionReceipt)**: 
    *   后台轮询 (Polling) 交易状态。
    *   一旦确认 (Confirmed)，`useEffect` 触发 -> 强制刷新余额。

## 3. 本质认知：浏览器是什么？

*   **浏览器 = 操作系统 / 虚拟机 (类似 EVM)**
    *   它提供环境（V8 引擎）来执行代码（JS）。
    *   它提供 API（DOM, Fetch, Storage）供代码调用。
    *   它提供沙箱（Sandbox）保证安全。

*   **框架 (Next.js) = 自动化流水线**
    *   它帮我们省去了手动可以 DOM、手动写路由、手动配打包器的繁琐工作。
    *   就像用 OpenZeppelin 写合约一样，只关注业务，不造轮子。

---
*Generated by Antigravity for User Concept Consolidation*
